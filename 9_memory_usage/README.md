# Создание локального модуля

### Описание создания модуля
В директории `mymodule-example`:
- `mymodule.h` и `mymodule.cpp` - непосредсвенно класс, выполняющий всю логику модуля. 
- `main.cpp` - файл, необходимый для присоединения модуля к системе робота. 
- `CMakeLists.txt` и `qiproject.xml ` - файлы, необходимые для компиляции с помощью `qibuild`.

В файле `mymodule.h` находится обычное описание класса, который наследует `public AL::ALModule`. Примечательно здесь лишь то, что в приватной секции находится переменная `AL::ALTextToSpeechProxy tts_;` - прокси для модуля `ALTextToSpeech`, необходимые для вызова функций этого модуля (например, `say`, как будет видно в дальнейшем).

В файле `mymodule.cpp` находится описание функций, входящих в состав модуля. Примечательно, что при создании объекта вызываются конструкторы `AL::ALModule(broker, name)` и `tts_(getParentBroker())`. 

Далее необходимо определить вызываемые методы. Для этого используются функции:

         functionName(<method_name>, <class_name>, <method_description>);
         
         BIND_METHOD(<method_reference>);
         
а также необязательные функции, которые добавляют описания к модулю, функциям, возвращаемым значениям и параметрам:

         addParam(<attribut_name>, <attribut_descrption>);
         
         setReturn(<return_name>, <return_description>);
         
         setModuleDescription(<module_description>);
         
### Важная заметка от разработчиков: 
Bound methods can only take const ref arguments of basic types,
or AL::ALValue or return basic types or an AL::ALValue.

Далее обратим внимание на метод нашего модуля `MyModule::sayWord`, которая с помощью прокси вызывает функцию, заставляющую робота сказать слово:

         tts_.say(word);
         
Теперь рассмотрим файл `main.cpp`, который содержит две функции: `int _createModule(boost::shared_ptr<AL::ALBroker> broker)` и `int _closeModule( )`. Эти функции вызываются при привязке и отвязке библиотеки, соответственно. 

В первой функции выполняются три магических действия, которые из создают наш модулю:

         AL::ALBrokerManager::setInstance(broker->fBrokerManager.lock());
         
         AL::ALBrokerManager::getInstance()->addBroker(broker);

         AL::ALModule::createModule<MyModule>(broker, "MyModule");
         
Несколько слов про make файл (`CMakeLists.txt`): примечателен он тем, что создаёт разделяемую библиотеку с именем `mymodule` в подпапке `naoqi`:

         qi_create_lib(mymodule SHARED ${_srcs} SUBFOLDER naoqi)

Более детально: при компиляции нашего модуля мы получим файл с расширением .so, который можно динамически прилинковать к системе робота. Важно, что при сборке нужно использовать toolchain для робота, поскольку эта библиотека будет запускать на нём, поэтому и компилировать нужно под его процессор. 

### Как динамически прилинковать библиотеку

* Добавить файл с расширением .so, который создался в папке /build-.../sdk/lib/naoqi в результате сборки, в `/home/nao/some_directory` на роботе (о том, как это сделать, можно ещё раз прочитать [здесь](https://github.com/robocupmipt/tutorials/blob/master/1_installation/connection-to-the-robot.md)). 
* В файле `/home/nao/naoqi/preferences/autoload.ini` на роботе добавить строчку:

        -> [user]
    
        -> /path/to/libmymodule.so

### Описание программы для подключения к модулю
В директории `connect-to-module`:
- `main.cpp` - файл программы, которая подключается через прокси к нашему модулю и вызывает его функции. 
- `CMakeLists.txt` и `qiproject.xml ` - файлы, необходимые для компиляции с помощью `qibuild`.

С 10-ой по 60-ую строку в main.cpp происходит парсинг аргументов командной строки: при запуске программы можно отправить аргументом (с помощью ключа) IP-адрес робота, на котором мы хотим исполнить эту программу, и/или номер порта, однако ещё не понятно, за что это отвечает и на что влияет.

Далее мы создаём своего собственного брокера, чтобы с его помощью обращаться к другим модулям, в том числе и к предоставляемым фреймворком по умолчанию:

         boost::shared_ptr<AL::ALBroker> broker = AL::ALBroker::createBroker(brokerName, "0.0.0.0", 54000, pip, pport);
         
здесь `pip` и `pport` - наш IP-адресс и номер нашего порта, `0.0.0.0` и `54000` - какие-то магические числа, `brokerName` - строковая константа, имя брокера (опять-таки непонятно, за что это отвечает и на что влияет).

Далее мы вызываем конструктор собственных прокси, чтобы с помощью них вызывать функции модуля (здесь `MyModule` - название модуля, к которому мы хотим обращаться по этим прокси):

        AL::ALProxy proxy(broker, "MyModule");
        
и обращаемся с помощью них к функции `sayWord`, передав в качестве аргумента строковую константу `"Sentence to say!"` и указав тип возвращаемого значения `bool`:
   
        proxy.call<bool>("sayWord", "Sentence to say!");
   
### Note: 
Если у вызываемой функции тип возвращаемого значения `void`, то нужно использовать `callVoid` вместо `call`.

Обратим внимание на файл `CMakeLists.txt`: в нём задаётся, что нужно создать обычный бинарник с именем `myproject`:

         qi_create_bin(myproject "main.cpp")
         
Есть два варианта, как запускать эту программу:
* скомпилировать программу для компьютера и запустить на нём, передав в качестве аргумента IP-адрес робота, используя ключ `--pip`.
* Скомпилировать программу для робота, используя cross-toolchain, и запустить уже на нём. При этом можно также передать IP-адрес, (причём даже другого робота, находящегося в той же локальной сети, просто программа будет выполняться на одном роботе, а инструкции слать другому). Если же не передавать IP-адрес через аргументы командной строки, то программа будет исполняться для дефолтного IP-адреса `127.0.0.1`, который означает, что действия будет выполнять тот робот, на котором эта программа запущена (но это надо ещё проверить).
